<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE4找所有玩家的血量 | 个人博客</title><meta name="author" content="admin"><meta name="copyright" content="admin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么要找所有玩家的血量？用于绘制所有玩家的血条，判断玩家是否死亡。 传统找法一般 FPS 射击游戏中的血量满血时都是数值100类型 float。所以我们满血的时候先精确扫描单浮点100，然后掉血了搜减少的数值。没掉血再搜不变的数值，直到找到血量地址。 找到后指针扫描最大5级偏移。扫描出结果后，要找基址是 &quot;BattleRoyaleTrainer-Win64-Shipping.exe&amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="UE4找所有玩家的血量">
<meta property="og:url" content="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="为什么要找所有玩家的血量？用于绘制所有玩家的血条，判断玩家是否死亡。 传统找法一般 FPS 射击游戏中的血量满血时都是数值100类型 float。所以我们满血的时候先精确扫描单浮点100，然后掉血了搜减少的数值。没掉血再搜不变的数值，直到找到血量地址。 找到后指针扫描最大5级偏移。扫描出结果后，要找基址是 &quot;BattleRoyaleTrainer-Win64-Shipping.exe&amp;q">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.p0.ee/usr/uploads/2021/06/3665838702.png">
<meta property="article:published_time" content="2021-06-21T02:41:06.000Z">
<meta property="article:modified_time" content="2025-10-30T02:51:52.317Z">
<meta property="article:author" content="admin">
<meta property="article:tag" content="UE4">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="内存分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.p0.ee/usr/uploads/2021/06/3665838702.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UE4找所有玩家的血量",
  "url": "https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/",
  "image": "https://blog.p0.ee/usr/uploads/2021/06/3665838702.png",
  "datePublished": "2021-06-21T02:41:06.000Z",
  "dateModified": "2025-10-30T02:51:52.317Z",
  "author": [
    {
      "@type": "Person",
      "name": "admin",
      "url": "https://blog.p0.ee/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/g.jpeg"><link rel="canonical" href="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE4找所有玩家的血量',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://p0.ee/"><i class="fa-fw fas fa-id-card"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/flink/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/Logo.png" alt="Logo"><span class="site-name">个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">UE4找所有玩家的血量</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://p0.ee/"><i class="fa-fw fas fa-id-card"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/flink/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">UE4找所有玩家的血量</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-06-21T02:41:06.000Z" title="发表于 2021-06-21 02:41:06">2021-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/windows/">windows</a></span></div><div class="meta-secondline"></div></div></div><article class="container post-content" id="article-container"><h2 id="为什么要找所有玩家的血量？"><a href="#为什么要找所有玩家的血量？" class="headerlink" title="为什么要找所有玩家的血量？"></a>为什么要找所有玩家的血量？</h2><p>用于绘制所有玩家的血条，判断玩家是否死亡。</p>
<h2 id="传统找法"><a href="#传统找法" class="headerlink" title="传统找法"></a>传统找法</h2><p>一般 FPS 射击游戏中的血量满血时都是数值100类型 float。所以我们满血的时候先精确扫描单浮点100，然后掉血了搜减少的数值。没掉血再搜不变的数值，直到找到血量地址。</p>
<p>找到后指针扫描最大5级偏移。扫描出结果后，要找基址是 <code>&quot;BattleRoyaleTrainer-Win64-Shipping.exe&quot;+02AEFFB8</code> ，并且偏移是 <code>0x30 -&gt; 0xB0</code> 后。因为我们要找的是所有玩家的血量，也就是 Actor 下的血量。</p>
<p>最终得到血量偏移为 <code>&quot;BattleRoyaleTrainer-Win64-Shipping.exe&quot;+02AEFFB8 -&gt; 0x30 -&gt; 0xB0 -&gt; 0x8 -&gt; 0x7C4</code>。其中 <code>0x8</code> 为遍历 ActorArray 的偏移。</p>
<h2 id="更简单的找法"><a href="#更简单的找法" class="headerlink" title="更简单的找法"></a>更简单的找法</h2><p>还有一种方式，找到自己的基址后，去分析结构。然后在里面搜索数值，没有受到伤害之前，基本都是100。找到所有可能为血量的地址后，再进行测试。比如修改，比如受伤后的变化，这样就可以直接确定血量偏移。</p>
<p><img src="/usr/uploads/2021/06/3665838702.png" alt="内存分析示例"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>有些游戏其他玩家的血量可能不会存储在本地，也就是在 ActorArray 下面可能找不到血量，也有可能是做了加密处理。这种情况下：</p>
<ul>
<li>绘制血条已经不可能</li>
<li>判断玩家死亡可以采用折中办法，如观察玩家骨骼数据</li>
</ul>
<p>一般 FPS 游戏中玩家死亡后：</p>
<ol>
<li>尸体会在地上停留几秒才会消失</li>
<li>消失后 Actor 并没有马上销毁，仍在 ActorArray 中</li>
<li>如果直接绘制会出现空框</li>
</ol>
<p>解决方案：</p>
<ul>
<li>分析人物结构，观察玩家活死时的数值变化规律</li>
<li>观察骨骼变化（即使 Actor 未销毁，骨骼数据消失也可判断尸体消失）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.p0.ee">admin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/">https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.p0.ee" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UE4/">UE4</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">内存分析</a></div><div class="post-share"><div class="social-share" data-image="/usr/uploads/2021/06/3665838702.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/" title="UE4找ComponentToWorld和骨骼数组"><img class="cover" src="/usr/uploads/2021/06/1089640715.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UE4找ComponentToWorld和骨骼数组</div></div><div class="info-2"><div class="info-item-1">为什么要找骨骼基址？找骨骼基址是为了实现绘制骨架和骨骼自瞄，比如瞄准头部骨骼、胸部骨骼。 找骨骼基址对自己的 Actor 的地址进行结构分析，防止分析错地址最好直接用 APawn，然后根据特征去查找。 ComponentToWorld 是 3x3 结构，最后一行数值不会动，最后一行数值一般是3个固定的数值和 0.00。例如：  1.00 1.00 1.00 0.00  2.50 2.50 2.50 0.00  ComponentToWorld位置根据特征，我们找到了 ComponentToWorld，得到偏移为:Actor.base -&gt; 0x378 -&gt; 0x180，其中 0x378 偏移是 Mesh 的偏移。  骨骼数组位置ComponentToWorld 和骨骼数组都在 Mesh 下面。找到 ComponentToWorld 后，很容易找到骨骼数组。骨骼数组在内存中表现很规律，偏移为:Actor.base -&gt; 0x378 -&gt;...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/" title="UE4找子弹和后坐力基址"><img class="cover" src="/usr/uploads/2021/06/588919298.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UE4找子弹和后坐力基址</div></div><div class="info-2"><div class="info-item-1">UE4子弹常识子弹在游戏中一般都会给出 UI 显示，我们可以根据子弹变化，很容易精确搜索到子弹的地址。而子弹的射速、后坐力等数据，基本都是在子弹内存区域前后范围内的。 找子弹基址多次精确搜索子弹数量，找到子弹数量的地址：  对这个地址进行指针扫描，扫描层级5。扫描出结果后，记住之前子弹的枪，然后重新上游戏。CE重新附加进程，切换到之前的枪并改变子弹数量后，在指针扫描器里重新扫描内存，输入现在子弹的数量，过滤掉失效地址。重复操作多次，就可以慢慢定位到基址。 扫描结果就算多次过滤后，一般也会剩下很多，我们找偏移中带 0x0 0x8 0x10 这样8字节的倍数的偏移量，这种偏移是指针数值的单个元素大小，指针数值的偏移基本的都是这样的。比如下面这个偏移 0x0 0x8 0x10，发现刚好对应我们3把枪的子弹数量。  找后坐力基址查看子弹的内存区域，观察有什么数值是开枪的过程中有变化的。  把这些数值都列为可疑数值加到地址列表，然后锁定数值为0，测试开枪有没有后坐力。 注意要把 CE...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/06/21/ue4/UE4%E5%BC%95%E6%93%8E%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/UE4%E5%BC%95%E6%93%8E%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="UE4引擎游戏结构和一些基础概念"><img class="cover" src="/usr/uploads/2021/06/482392516.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4引擎游戏结构和一些基础概念</div></div><div class="info-2"><div class="info-item-1">UE4游戏结构概览小龙讲师总结的结构: 常用结构概念UWorld 单例对象，逆向UE4游戏的重要入口 可获取UGameInstance和ULevel  UGameInstanceUWorld类的属性: 1struct UGameInstance* OwningGameInstance;  ULocalPlayerUGameInstance类的属性: 1struct TArray&lt;struct ULocalPlayer*&gt; LocalPlayers; 数组的第一个元素即为当前角色的ULocalPlayer。 APlayerControllerULocalPlayer父类(UPlayer)的属性: 1struct APlayerController* PlayerController; 包含APawn、APlayerCameraManager等重要数据。 APawn 继承自AActor 在UE4逆向中称为InPawn 位于AController类:  1struct APawn*...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/" title="UE4找Actor区分标识"><img class="cover" src="/usr/uploads/2021/06/1057996391.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找Actor区分标识</div></div><div class="info-2"><div class="info-item-1">UE4找Actor区分标识标识的作用我们如何区分 ActorArray 中的 Actor 是敌人、队友、自己、物品还是其他东西？比较通用的做法是对比多个 Actor 的结构，找出不同类型的 Actor 在同一偏移，数值的异同规律。 比如在 Actor 下 0x555 偏移，类型为 4 Bytes，是敌人的时候这个数值为0，是队友的时候数值为1，是自己的时候数值为2，不是人的时候数值为3。这样就可以区分出人和其他物品，并且可以区分出人里面的敌人、队友和自己。这就是找标识的作用。 由于我测试的游戏是一个单机游戏，相对来说是比较容易对比 Actor 结构中的数据。 找出区分的标识先遍历 ActorArray 并绘制所有 Actor 的地址，然后观察绘制出来的地址。发现自己身上有多个地址，这是因为身上的装备也是 Actor。 我发现在人物播放闲置动画或下蹲的时候，不会移动的是人物的地址，会移动的是物品的地址。（只是刚好这个游戏是这样的）   还有一种区分方式是把自己身上的所有地址都添加到 CE 地址列表，然后挨个浏览内存区域，类型改为 float，将附近的 1.0...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/" title="UE4找ComponentToWorld和骨骼数组"><img class="cover" src="/usr/uploads/2021/06/1089640715.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找ComponentToWorld和骨骼数组</div></div><div class="info-2"><div class="info-item-1">为什么要找骨骼基址？找骨骼基址是为了实现绘制骨架和骨骼自瞄，比如瞄准头部骨骼、胸部骨骼。 找骨骼基址对自己的 Actor 的地址进行结构分析，防止分析错地址最好直接用 APawn，然后根据特征去查找。 ComponentToWorld 是 3x3 结构，最后一行数值不会动，最后一行数值一般是3个固定的数值和 0.00。例如：  1.00 1.00 1.00 0.00  2.50 2.50 2.50 0.00  ComponentToWorld位置根据特征，我们找到了 ComponentToWorld，得到偏移为:Actor.base -&gt; 0x378 -&gt; 0x180，其中 0x378 偏移是 Mesh 的偏移。  骨骼数组位置ComponentToWorld 和骨骼数组都在 Mesh 下面。找到 ComponentToWorld 后，很容易找到骨骼数组。骨骼数组在内存中表现很规律，偏移为:Actor.base -&gt; 0x378 -&gt;...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BECount%E5%9F%BA%E5%9D%80/UE4%E6%89%BECount%E5%9F%BA%E5%9D%80/" title="UE4找Count基址"><img class="cover" src="/usr/uploads/2021/06/3564924053.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找Count基址</div></div><div class="info-2"><div class="info-item-1">什么是Count？Count 就是 UE4 引擎开发的游戏在运行过程中动态创建的 Actor 的数量，也可以说是在当前玩家一定范围内的 Actor 的数量。因为如果离得太远，由于游戏性能优化原因，是不会把非常远的 Actor 也获取的。 我们找Count来干什么？找到 Count，我们也就找到了 UWorld、ULevel 和 ActorArray 的地址。因为 Count 的地址都是在 UWorld 里的 ULevel 下的。 ActorArray 在 UE4 里其实是一个 TArray 的结构体：  第一个变量为指向 Actor 指针数组的指针 第二个变量 Num 就是这个数组的长度，也就是 Count  所以 Count 的地址减去8字节，就是 ActorArray 的地址。获取这两个值后，就可以遍历所有 Actor。 本文以单机游戏 Battle Royale Trainer...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/" title="UE4找子弹和后坐力基址"><img class="cover" src="/usr/uploads/2021/06/588919298.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找子弹和后坐力基址</div></div><div class="info-2"><div class="info-item-1">UE4子弹常识子弹在游戏中一般都会给出 UI 显示，我们可以根据子弹变化，很容易精确搜索到子弹的地址。而子弹的射速、后坐力等数据，基本都是在子弹内存区域前后范围内的。 找子弹基址多次精确搜索子弹数量，找到子弹数量的地址：  对这个地址进行指针扫描，扫描层级5。扫描出结果后，记住之前子弹的枪，然后重新上游戏。CE重新附加进程，切换到之前的枪并改变子弹数量后，在指针扫描器里重新扫描内存，输入现在子弹的数量，过滤掉失效地址。重复操作多次，就可以慢慢定位到基址。 扫描结果就算多次过滤后，一般也会剩下很多，我们找偏移中带 0x0 0x8 0x10 这样8字节的倍数的偏移量，这种偏移是指针数值的单个元素大小，指针数值的偏移基本的都是这样的。比如下面这个偏移 0x0 0x8 0x10，发现刚好对应我们3把枪的子弹数量。  找后坐力基址查看子弹的内存区域，观察有什么数值是开枪的过程中有变化的。  把这些数值都列为可疑数值加到地址列表，然后锁定数值为0，测试开枪有没有后坐力。 注意要把 CE...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/" title="UE4找摄像机矩阵"><img class="cover" src="/usr/uploads/2021/06/733412634.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找摄像机矩阵</div></div><div class="info-2"><div class="info-item-1">为什么需要摄像机矩阵？我们可以用屏幕尺寸 + Actor 三维坐标 + 摄像机矩阵，通过固定算法计算出 Actor 的屏幕坐标，从而实现绘制 Actor 的数据，实现透视效果。 常规方式 先扫未知的初始值，类型单浮点 移动镜头并搜索变动的数值，再移动再搜索，反复操作 不移动镜头，搜索不变的数值，反复操作 最后搜索结果数量不再减少时： 将结果列表里当前值带 E 的和绿色的静态地址删掉 依次选择地址浏览相关内存区域，数据类型切为单浮点 转动镜头，根据摄像机居中特征分析是否是矩阵数据    最终找到矩阵如下： 摄像机矩阵的特征 UE4 摄像机矩阵的第三列是 0.00 0.00 0.00 x.00，最后一个数值不固定，前面3个 0.00 固定 除了第四行中会出现较大的数值，前面三行都不会出现较大数值 一般不移动镜头时，摄像机矩阵数值不会变化 UE4 的摄像机矩阵的动态地址一般重启游戏才会变化，切换场景和房间一般不会变化  特征码方式UE4 还可以使用摄像机矩阵的特征码快速定位，通用矩阵特征码： 100 00 00 00 00 00 00 00 00 00 80 3F 00 00 80...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">admin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个前端程序员，爱折腾，爱技术分享</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">为什么要找所有玩家的血量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%89%BE%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">传统找法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%BE%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">更简单的找法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/10/%E5%AE%89%E5%8D%93/%E5%88%A9%E7%94%A8github-Action%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/" title="利用github Action编译安卓内核驱动">利用github Action编译安卓内核驱动</a><time datetime="2024-11-10T04:58:06.000Z" title="发表于 2024-11-10 04:58:06">2024-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/10/vue/%E8%A7%A3%E5%86%B3safari%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8window-open%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/" title="解决safari浏览器使用window.open失效的问题">解决safari浏览器使用window.open失效的问题</a><time datetime="2023-07-10T04:58:06.000Z" title="发表于 2023-07-10 04:58:06">2023-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/02/Cloudflare%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Docker%E9%95%9C%E5%83%8F%E6%BA%90/" title="Cloudflare搭建私有Docker镜像源">Cloudflare搭建私有Docker镜像源</a><time datetime="2023-02-02T04:58:06.000Z" title="发表于 2023-02-02 04:58:06">2023-02-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/20/docker%E8%AE%B0%E5%BD%95/" title="Docker记录">Docker记录</a><time datetime="2022-06-20T04:58:06.000Z" title="发表于 2022-06-20 04:58:06">2022-06-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/07/vue/vue3%E5%85%B6%E4%BB%96/" title="vue3其他">vue3其他</a><time datetime="2022-02-07T04:58:06.000Z" title="发表于 2022-02-07 04:58:06">2022-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By admin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.p0.ee',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.p0.ee',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="1" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script></div></body></html>