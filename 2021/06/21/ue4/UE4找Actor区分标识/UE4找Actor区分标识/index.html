<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE4找Actor区分标识 | 个人博客</title><meta name="author" content="admin"><meta name="copyright" content="admin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UE4找Actor区分标识标识的作用我们如何区分 ActorArray 中的 Actor 是敌人、队友、自己、物品还是其他东西？比较通用的做法是对比多个 Actor 的结构，找出不同类型的 Actor 在同一偏移，数值的异同规律。 比如在 Actor 下 0x555 偏移，类型为 4 Bytes，是敌人的时候这个数值为0，是队友的时候数值为1，是自己的时候数值为2，不是人的时候数值为3。这样就可以">
<meta property="og:type" content="article">
<meta property="og:title" content="UE4找Actor区分标识">
<meta property="og:url" content="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="UE4找Actor区分标识标识的作用我们如何区分 ActorArray 中的 Actor 是敌人、队友、自己、物品还是其他东西？比较通用的做法是对比多个 Actor 的结构，找出不同类型的 Actor 在同一偏移，数值的异同规律。 比如在 Actor 下 0x555 偏移，类型为 4 Bytes，是敌人的时候这个数值为0，是队友的时候数值为1，是自己的时候数值为2，不是人的时候数值为3。这样就可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.p0.ee/usr/uploads/2021/06/1057996391.png">
<meta property="article:published_time" content="2021-06-21T02:35:30.000Z">
<meta property="article:modified_time" content="2025-10-30T02:51:52.317Z">
<meta property="article:author" content="admin">
<meta property="article:tag" content="UE4">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="内存分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.p0.ee/usr/uploads/2021/06/1057996391.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UE4找Actor区分标识",
  "url": "https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/",
  "image": "https://blog.p0.ee/usr/uploads/2021/06/1057996391.png",
  "datePublished": "2021-06-21T02:35:30.000Z",
  "dateModified": "2025-10-30T02:51:52.317Z",
  "author": [
    {
      "@type": "Person",
      "name": "admin",
      "url": "https://blog.p0.ee/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/g.jpeg"><link rel="canonical" href="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE4找Actor区分标识',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://p0.ee/"><i class="fa-fw fas fa-id-card"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/flink/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/Logo.png" alt="Logo"><span class="site-name">个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">UE4找Actor区分标识</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://p0.ee/"><i class="fa-fw fas fa-id-card"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/flink/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">UE4找Actor区分标识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-06-21T02:35:30.000Z" title="发表于 2021-06-21 02:35:30">2021-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/windows/">windows</a></span></div><div class="meta-secondline"></div></div></div><article class="container post-content" id="article-container"><h1 id="UE4找Actor区分标识"><a href="#UE4找Actor区分标识" class="headerlink" title="UE4找Actor区分标识"></a>UE4找Actor区分标识</h1><h2 id="标识的作用"><a href="#标识的作用" class="headerlink" title="标识的作用"></a>标识的作用</h2><p>我们如何区分 ActorArray 中的 Actor 是敌人、队友、自己、物品还是其他东西？比较通用的做法是对比多个 Actor 的结构，找出不同类型的 Actor 在同一偏移，数值的异同规律。</p>
<p>比如在 Actor 下 0x555 偏移，类型为 4 Bytes，是敌人的时候这个数值为0，是队友的时候数值为1，是自己的时候数值为2，不是人的时候数值为3。这样就可以区分出人和其他物品，并且可以区分出人里面的敌人、队友和自己。这就是找标识的作用。</p>
<p>由于我测试的游戏是一个单机游戏，相对来说是比较容易对比 Actor 结构中的数据。</p>
<h2 id="找出区分的标识"><a href="#找出区分的标识" class="headerlink" title="找出区分的标识"></a>找出区分的标识</h2><p>先遍历 ActorArray 并绘制所有 Actor 的地址，然后观察绘制出来的地址。发现自己身上有多个地址，这是因为身上的装备也是 Actor。</p>
<div class="note info flat"><p>我发现在人物播放闲置动画或下蹲的时候，不会移动的是人物的地址，会移动的是物品的地址。（只是刚好这个游戏是这样的）</p>
</div>

<p>还有一种区分方式是把自己身上的所有地址都添加到 CE 地址列表，然后挨个浏览内存区域，类型改为 float，将附近的 1.0 数值改为其他数值检查人物是否有加速效果。如果有加速效果，则说明这地址是人物的地址。这是 UE4 引擎结构的原因，加速控制的数值就是 Actor 下面很靠前的偏移，类型是 float。</p>
<div class="note warning flat"><p>注意：有些第一人称游戏，看不到自己身上的一些地址，可以通过调整坐标，让地址显示出来。比如调整自己的 x 坐标增加 50-200，再转屏幕坐标。这样就可以把本该绘制在自己身上的地址绘制在自己旁边。</p>
</div>

<p><img src="/usr/uploads/2021/06/1057996391.png" alt="Actor内存布局"></p>
<p>使用自己的人物地址、多个敌人的人物地址、物品的地址去结构分析，找到能够区分他们的条件。</p>
<p><img src="/usr/uploads/2021/06/1152388348.png" alt="Actor内存布局分析"></p>
<p>观察自己的人物数值、敌人的人物数值、物品数值：</p>
<ul>
<li>自己的人物数值和所有敌人的人物数值相同，但于物品的数值不同，则可用来区分人物和物品。</li>
<li>自己的人物数值、所有敌人的人物数值、物品的数值都不同，可以用来区分是自己还是敌人。</li>
</ul>
<p><img src="/usr/uploads/2021/06/41817864.png" alt="Actor数值对比"></p>
<h3 id="偏移数据记录"><a href="#偏移数据记录" class="headerlink" title="偏移数据记录"></a>偏移数据记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">人物和模型区分</span><br><span class="line">50 1-人物 0-模型-----------没变</span><br><span class="line">54 4-人物 0-模型-----------没变</span><br><span class="line">84 258-人物 2-模型-----------没变</span><br><span class="line">B8 512-人物 0-模型-----------没变</span><br><span class="line">138 3-人物 1-模型 float-----------没变</span><br><span class="line">154 4-人物 0-模型-----------没变</span><br><span class="line">298 10-人物 2-模型-----------没变</span><br><span class="line">29C 24-人物 4-模型-----------没变</span><br><span class="line">2A0 1023-人物 3-模型-----------没变</span><br><span class="line">2B8 10-人物 2-模型-----------没变</span><br><span class="line">2C8 2-人物 1-模型-----------没变</span><br><span class="line">2D8 16-人物 1-模型-----------没变</span><br><span class="line">308 6-人物 2-模型-----------没变</span><br><span class="line">30C 24-人物 4-模型-----------没变</span><br><span class="line"></span><br><span class="line">自己和敌人区分</span><br><span class="line">150 3-自己 1-敌人 0-模型</span><br></pre></td></tr></table></figure>

<h2 id="网络游戏"><a href="#网络游戏" class="headerlink" title="网络游戏"></a>网络游戏</h2><p>在网络游戏中，敌人和队友可不会站桩等你去对比数据，所以可以将想要对比的 Actor 地址挨个结构分析并保存数值到本地 txt 文本文件，然后再用其他文本对比工具来对比数据。比如免费开源的 WinMerge。</p>
<p>我们可以在代码中实现拷贝 Actor 地址到剪贴板，从而实现快速收集需要分析的结构。</p>
<div class="note success flat"><p>比如我可以像自瞄那样计算目标到准星的距离，将距离准星距离最新的 Actor 在我们按下某个快捷键的时候绘制出特殊的文字（文字更大、颜色和其他不一样之类的），并且使用拷贝这个地址到剪贴板。</p>
</div>

<h2 id="UE4更好的区分标识办法"><a href="#UE4更好的区分标识办法" class="headerlink" title="UE4更好的区分标识办法"></a>UE4更好的区分标识办法</h2><p>在 UE4 中，我们除了通过上面说的找不同 Actor 的异同标识来区分类型外，还有一种更精准并且更容易的方式。</p>
<p>首先需要熟悉一个 UE4 的固定结构，也就是 UWorld -&gt; GameInstance -&gt; LocalPlayer -&gt; PlayerController -&gt; APawn，而 APawn 则和 ActorArray 中某个 Actor 是同一个对象，也就是玩家自己的 Actor。</p>
<p>有了这个结构，我们就可以在遍历 ActorArray 的时候，判断和 APawn 地址相同的 Actor 就是玩家自己。</p>
<h2 id="GName查找和算法"><a href="#GName查找和算法" class="headerlink" title="GName查找和算法"></a>GName查找和算法</h2><ol>
<li>字符串搜索 MulticastDelegateProperty</li>
<li>搜到结果后，查看内存浏览器，切换到字节类型显示</li>
<li>向上翻，查找顶部有没有 ….*.None 开头</li>
<li>如果是则鼠标放 * 上，得到一个地址，加入地址列表里：</li>
</ol>
<p><img src="/usr/uploads/2021/06/2819542625.png" alt="GName搜索"></p>
<p>对这个地址搜索16进制8字节，得到一个静态地址：</p>
<p><img src="/usr/uploads/2021/06/3816624879.png" alt="静态地址"></p>
<p>这个静态地址减去 0x10，就是 Gname 入口地址：</p>
<p><img src="/usr/uploads/2021/06/3754720445.png" alt="Gname入口"></p>
<p>读出每个 Actor 的蓝图类名后，像绘制基址那样绘制出来，观察并区分即可。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.p0.ee">admin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/">https://blog.p0.ee/2021/06/21/ue4/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.p0.ee" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UE4/">UE4</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">内存分析</a></div><div class="post-share"><div class="social-share" data-image="/usr/uploads/2021/06/1057996391.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/" title="UE4找摄像机矩阵"><img class="cover" src="/usr/uploads/2021/06/733412634.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UE4找摄像机矩阵</div></div><div class="info-2"><div class="info-item-1">为什么需要摄像机矩阵？我们可以用屏幕尺寸 + Actor 三维坐标 + 摄像机矩阵，通过固定算法计算出 Actor 的屏幕坐标，从而实现绘制 Actor 的数据，实现透视效果。 常规方式 先扫未知的初始值，类型单浮点 移动镜头并搜索变动的数值，再移动再搜索，反复操作 不移动镜头，搜索不变的数值，反复操作 最后搜索结果数量不再减少时： 将结果列表里当前值带 E 的和绿色的静态地址删掉 依次选择地址浏览相关内存区域，数据类型切为单浮点 转动镜头，根据摄像机居中特征分析是否是矩阵数据    最终找到矩阵如下： 摄像机矩阵的特征 UE4 摄像机矩阵的第三列是 0.00 0.00 0.00 x.00，最后一个数值不固定，前面3个 0.00 固定 除了第四行中会出现较大的数值，前面三行都不会出现较大数值 一般不移动镜头时，摄像机矩阵数值不会变化 UE4 的摄像机矩阵的动态地址一般重启游戏才会变化，切换场景和房间一般不会变化  特征码方式UE4 还可以使用摄像机矩阵的特征码快速定位，通用矩阵特征码： 100 00 00 00 00 00 00 00 00 00 80 3F 00 00 80...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/" title="UE4找ComponentToWorld和骨骼数组"><img class="cover" src="/usr/uploads/2021/06/1089640715.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UE4找ComponentToWorld和骨骼数组</div></div><div class="info-2"><div class="info-item-1">为什么要找骨骼基址？找骨骼基址是为了实现绘制骨架和骨骼自瞄，比如瞄准头部骨骼、胸部骨骼。 找骨骼基址对自己的 Actor 的地址进行结构分析，防止分析错地址最好直接用 APawn，然后根据特征去查找。 ComponentToWorld 是 3x3 结构，最后一行数值不会动，最后一行数值一般是3个固定的数值和 0.00。例如：  1.00 1.00 1.00 0.00  2.50 2.50 2.50 0.00  ComponentToWorld位置根据特征，我们找到了 ComponentToWorld，得到偏移为:Actor.base -&gt; 0x378 -&gt; 0x180，其中 0x378 偏移是 Mesh 的偏移。  骨骼数组位置ComponentToWorld 和骨骼数组都在 Mesh 下面。找到 ComponentToWorld 后，很容易找到骨骼数组。骨骼数组在内存中表现很规律，偏移为:Actor.base -&gt; 0x378 -&gt;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/06/21/ue4/UE4%E5%BC%95%E6%93%8E%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/UE4%E5%BC%95%E6%93%8E%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="UE4引擎游戏结构和一些基础概念"><img class="cover" src="/usr/uploads/2021/06/482392516.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4引擎游戏结构和一些基础概念</div></div><div class="info-2"><div class="info-item-1">UE4游戏结构概览小龙讲师总结的结构: 常用结构概念UWorld 单例对象，逆向UE4游戏的重要入口 可获取UGameInstance和ULevel  UGameInstanceUWorld类的属性: 1struct UGameInstance* OwningGameInstance;  ULocalPlayerUGameInstance类的属性: 1struct TArray&lt;struct ULocalPlayer*&gt; LocalPlayers; 数组的第一个元素即为当前角色的ULocalPlayer。 APlayerControllerULocalPlayer父类(UPlayer)的属性: 1struct APlayerController* PlayerController; 包含APawn、APlayerCameraManager等重要数据。 APawn 继承自AActor 在UE4逆向中称为InPawn 位于AController类:  1struct APawn*...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/UE4%E6%89%BEComponentToWorld%E5%92%8C%E9%AA%A8%E9%AA%BC%E6%95%B0%E7%BB%84/" title="UE4找ComponentToWorld和骨骼数组"><img class="cover" src="/usr/uploads/2021/06/1089640715.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找ComponentToWorld和骨骼数组</div></div><div class="info-2"><div class="info-item-1">为什么要找骨骼基址？找骨骼基址是为了实现绘制骨架和骨骼自瞄，比如瞄准头部骨骼、胸部骨骼。 找骨骼基址对自己的 Actor 的地址进行结构分析，防止分析错地址最好直接用 APawn，然后根据特征去查找。 ComponentToWorld 是 3x3 结构，最后一行数值不会动，最后一行数值一般是3个固定的数值和 0.00。例如：  1.00 1.00 1.00 0.00  2.50 2.50 2.50 0.00  ComponentToWorld位置根据特征，我们找到了 ComponentToWorld，得到偏移为:Actor.base -&gt; 0x378 -&gt; 0x180，其中 0x378 偏移是 Mesh 的偏移。  骨骼数组位置ComponentToWorld 和骨骼数组都在 Mesh 下面。找到 ComponentToWorld 后，很容易找到骨骼数组。骨骼数组在内存中表现很规律，偏移为:Actor.base -&gt; 0x378 -&gt;...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BECount%E5%9F%BA%E5%9D%80/UE4%E6%89%BECount%E5%9F%BA%E5%9D%80/" title="UE4找Count基址"><img class="cover" src="/usr/uploads/2021/06/3564924053.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找Count基址</div></div><div class="info-2"><div class="info-item-1">什么是Count？Count 就是 UE4 引擎开发的游戏在运行过程中动态创建的 Actor 的数量，也可以说是在当前玩家一定范围内的 Actor 的数量。因为如果离得太远，由于游戏性能优化原因，是不会把非常远的 Actor 也获取的。 我们找Count来干什么？找到 Count，我们也就找到了 UWorld、ULevel 和 ActorArray 的地址。因为 Count 的地址都是在 UWorld 里的 ULevel 下的。 ActorArray 在 UE4 里其实是一个 TArray 的结构体：  第一个变量为指向 Actor 指针数组的指针 第二个变量 Num 就是这个数组的长度，也就是 Count  所以 Count 的地址减去8字节，就是 ActorArray 的地址。获取这两个值后，就可以遍历所有 Actor。 本文以单机游戏 Battle Royale Trainer...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/UE4%E6%89%BE%E5%AD%90%E5%BC%B9%E5%92%8C%E5%90%8E%E5%9D%90%E5%8A%9B%E5%9F%BA%E5%9D%80/" title="UE4找子弹和后坐力基址"><img class="cover" src="/usr/uploads/2021/06/588919298.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找子弹和后坐力基址</div></div><div class="info-2"><div class="info-item-1">UE4子弹常识子弹在游戏中一般都会给出 UI 显示，我们可以根据子弹变化，很容易精确搜索到子弹的地址。而子弹的射速、后坐力等数据，基本都是在子弹内存区域前后范围内的。 找子弹基址多次精确搜索子弹数量，找到子弹数量的地址：  对这个地址进行指针扫描，扫描层级5。扫描出结果后，记住之前子弹的枪，然后重新上游戏。CE重新附加进程，切换到之前的枪并改变子弹数量后，在指针扫描器里重新扫描内存，输入现在子弹的数量，过滤掉失效地址。重复操作多次，就可以慢慢定位到基址。 扫描结果就算多次过滤后，一般也会剩下很多，我们找偏移中带 0x0 0x8 0x10 这样8字节的倍数的偏移量，这种偏移是指针数值的单个元素大小，指针数值的偏移基本的都是这样的。比如下面这个偏移 0x0 0x8 0x10，发现刚好对应我们3把枪的子弹数量。  找后坐力基址查看子弹的内存区域，观察有什么数值是开枪的过程中有变化的。  把这些数值都列为可疑数值加到地址列表，然后锁定数值为0，测试开枪有没有后坐力。 注意要把 CE...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/UE4%E6%89%BE%E6%89%80%E6%9C%89%E7%8E%A9%E5%AE%B6%E7%9A%84%E8%A1%80%E9%87%8F/" title="UE4找所有玩家的血量"><img class="cover" src="/usr/uploads/2021/06/3665838702.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找所有玩家的血量</div></div><div class="info-2"><div class="info-item-1">为什么要找所有玩家的血量？用于绘制所有玩家的血条，判断玩家是否死亡。 传统找法一般 FPS 射击游戏中的血量满血时都是数值100类型 float。所以我们满血的时候先精确扫描单浮点100，然后掉血了搜减少的数值。没掉血再搜不变的数值，直到找到血量地址。 找到后指针扫描最大5级偏移。扫描出结果后，要找基址是 &quot;BattleRoyaleTrainer-Win64-Shipping.exe&quot;+02AEFFB8 ，并且偏移是 0x30 -&gt; 0xB0 后。因为我们要找的是所有玩家的血量，也就是 Actor 下的血量。 最终得到血量偏移为 &quot;BattleRoyaleTrainer-Win64-Shipping.exe&quot;+02AEFFB8 -&gt; 0x30 -&gt; 0xB0 -&gt; 0x8 -&gt; 0x7C4。其中 0x8 为遍历 ActorArray...</div></div></div></a><a class="pagination-related" href="/2021/06/21/ue4/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/UE4%E6%89%BE%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5/" title="UE4找摄像机矩阵"><img class="cover" src="/usr/uploads/2021/06/733412634.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="info-item-2">UE4找摄像机矩阵</div></div><div class="info-2"><div class="info-item-1">为什么需要摄像机矩阵？我们可以用屏幕尺寸 + Actor 三维坐标 + 摄像机矩阵，通过固定算法计算出 Actor 的屏幕坐标，从而实现绘制 Actor 的数据，实现透视效果。 常规方式 先扫未知的初始值，类型单浮点 移动镜头并搜索变动的数值，再移动再搜索，反复操作 不移动镜头，搜索不变的数值，反复操作 最后搜索结果数量不再减少时： 将结果列表里当前值带 E 的和绿色的静态地址删掉 依次选择地址浏览相关内存区域，数据类型切为单浮点 转动镜头，根据摄像机居中特征分析是否是矩阵数据    最终找到矩阵如下： 摄像机矩阵的特征 UE4 摄像机矩阵的第三列是 0.00 0.00 0.00 x.00，最后一个数值不固定，前面3个 0.00 固定 除了第四行中会出现较大的数值，前面三行都不会出现较大数值 一般不移动镜头时，摄像机矩阵数值不会变化 UE4 的摄像机矩阵的动态地址一般重启游戏才会变化，切换场景和房间一般不会变化  特征码方式UE4 还可以使用摄像机矩阵的特征码快速定位，通用矩阵特征码： 100 00 00 00 00 00 00 00 00 00 80 3F 00 00 80...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">admin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个前端程序员，爱折腾，爱技术分享</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UE4%E6%89%BEActor%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">UE4找Actor区分标识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">标识的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%8C%BA%E5%88%86%E7%9A%84%E6%A0%87%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">找出区分的标识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">偏移数据记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F"><span class="toc-number">1.3.</span> <span class="toc-text">网络游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UE4%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8C%BA%E5%88%86%E6%A0%87%E8%AF%86%E5%8A%9E%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">UE4更好的区分标识办法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GName%E6%9F%A5%E6%89%BE%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">GName查找和算法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/10/%E5%AE%89%E5%8D%93/%E5%88%A9%E7%94%A8github-Action%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/" title="利用github Action编译安卓内核驱动">利用github Action编译安卓内核驱动</a><time datetime="2024-11-10T04:58:06.000Z" title="发表于 2024-11-10 04:58:06">2024-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/10/vue/%E8%A7%A3%E5%86%B3safari%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8window-open%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/" title="解决safari浏览器使用window.open失效的问题">解决safari浏览器使用window.open失效的问题</a><time datetime="2023-07-10T04:58:06.000Z" title="发表于 2023-07-10 04:58:06">2023-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/02/Cloudflare%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Docker%E9%95%9C%E5%83%8F%E6%BA%90/" title="Cloudflare搭建私有Docker镜像源">Cloudflare搭建私有Docker镜像源</a><time datetime="2023-02-02T04:58:06.000Z" title="发表于 2023-02-02 04:58:06">2023-02-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/20/docker%E8%AE%B0%E5%BD%95/" title="Docker记录">Docker记录</a><time datetime="2022-06-20T04:58:06.000Z" title="发表于 2022-06-20 04:58:06">2022-06-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/07/vue/vue3%E5%85%B6%E4%BB%96/" title="vue3其他">vue3其他</a><time datetime="2022-02-07T04:58:06.000Z" title="发表于 2022-02-07 04:58:06">2022-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By admin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.p0.ee',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.p0.ee',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="1" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script></div></body></html>